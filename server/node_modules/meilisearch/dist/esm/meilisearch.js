/*
 * Bundle: MeiliSearch
 * Project: MeiliSearch - Javascript API
 * Author: Quentin de Quelen <quentin@meilisearch.com>
 * Copyright: 2019, MeiliSearch
 */
import { Index } from "./indexes.js";
import { ErrorStatusCode } from "./types/index.js";
import { HttpRequests } from "./http-requests.js";
import { getHttpRequestsWithEnqueuedTaskPromise, TaskClient, } from "./task.js";
import { BatchClient } from "./batch.js";
export class MeiliSearch {
    config;
    httpRequest;
    #taskClient;
    get tasks() {
        return this.#taskClient;
    }
    #batchClient;
    get batches() {
        return this.#batchClient;
    }
    #httpRequestsWithTask;
    /**
     * Creates new MeiliSearch instance
     *
     * @param config - Configuration object
     */
    constructor(config) {
        this.config = config;
        this.httpRequest = new HttpRequests(config);
        this.#taskClient = new TaskClient(this.httpRequest, config.defaultWaitOptions);
        this.#batchClient = new BatchClient(this.httpRequest);
        this.#httpRequestsWithTask = getHttpRequestsWithEnqueuedTaskPromise(this.httpRequest, this.tasks);
    }
    /**
     * Return an Index instance
     *
     * @param indexUid - The index UID
     * @returns Instance of Index
     */
    index(indexUid) {
        return new Index(this.config, indexUid);
    }
    /**
     * Gather information about an index by calling MeiliSearch and return an
     * Index instance with the gathered information
     *
     * @param indexUid - The index UID
     * @returns Promise returning Index instance
     */
    async getIndex(indexUid) {
        return new Index(this.config, indexUid).fetchInfo();
    }
    /**
     * Gather information about an index by calling MeiliSearch and return the raw
     * JSON response
     *
     * @param indexUid - The index UID
     * @returns Promise returning index information
     */
    async getRawIndex(indexUid) {
        return new Index(this.config, indexUid).getRawInfo();
    }
    /**
     * Get all the indexes as Index instances.
     *
     * @param parameters - Parameters to browse the indexes
     * @returns Promise returning array of raw index information
     */
    async getIndexes(parameters) {
        const rawIndexes = await this.getRawIndexes(parameters);
        const indexes = rawIndexes.results.map((index) => new Index(this.config, index.uid, index.primaryKey));
        return { ...rawIndexes, results: indexes };
    }
    /**
     * Get all the indexes in their raw value (no Index instances).
     *
     * @param parameters - Parameters to browse the indexes
     * @returns Promise returning array of raw index information
     */
    async getRawIndexes(parameters) {
        return await this.httpRequest.get({
            path: "indexes",
            params: parameters,
        });
    }
    /**
     * Create a new index
     *
     * @param uid - The index UID
     * @param options - Index options
     * @returns Promise returning Index instance
     */
    createIndex(uid, options) {
        return Index.create(uid, options, this.config);
    }
    /**
     * Update an index
     *
     * @param uid - The index UID
     * @param options - Index options to update
     * @returns Promise returning Index instance after updating
     */
    updateIndex(uid, options) {
        return new Index(this.config, uid).update(options);
    }
    /**
     * Delete an index
     *
     * @param uid - The index UID
     * @returns Promise which resolves when index is deleted successfully
     */
    deleteIndex(uid) {
        return new Index(this.config, uid).delete();
    }
    /**
     * Deletes an index if it already exists.
     *
     * @param uid - The index UID
     * @returns Promise which resolves to true when index exists and is deleted
     *   successfully, otherwise false if it does not exist
     */
    async deleteIndexIfExists(uid) {
        try {
            await this.deleteIndex(uid);
            return true;
        }
        catch (e) {
            if (e?.cause?.code ===
                ErrorStatusCode.INDEX_NOT_FOUND) {
                return false;
            }
            throw e;
        }
    }
    /**
     * Swaps a list of index tuples.
     *
     * @param params - List of indexes tuples to swap.
     * @returns Promise returning object of the enqueued task
     */
    swapIndexes(params) {
        return this.#httpRequestsWithTask.post({
            path: "/swap-indexes",
            body: params,
        });
    }
    ///
    /// Multi Search
    ///
    /**
     * Perform multiple search queries.
     *
     * It is possible to make multiple search queries on the same index or on
     * different ones. With network feature enabled, you can also search across
     * remote instances.
     *
     * @example
     *
     * ```ts
     * client.multiSearch({
     *   queries: [
     *     { indexUid: "movies", q: "wonder" },
     *     { indexUid: "books", q: "flower" },
     *   ],
     * });
     *
     * // Federated search with remote instance (requires network feature enabled)
     * client.multiSearch({
     *   federation: {},
     *   queries: [
     *     {
     *       indexUid: "movies",
     *       q: "wonder",
     *       federationOptions: {
     *         remote: "meilisearch instance name",
     *       },
     *     },
     *     {
     *       indexUid: "movies",
     *       q: "wonder",
     *       federationOptions: {
     *         remote: "meilisearch instance name",
     *       },
     *     },
     *   ],
     * });
     * ```
     *
     * @param queries - Search queries
     * @param extraRequestInit - Additional request configuration options
     * @returns Promise containing the search responses
     * @see {@link https://www.meilisearch.com/docs/learn/multi_search/implement_sharding#perform-a-search}
     */
    async multiSearch(queries, extraRequestInit) {
        return await this.httpRequest.post({
            path: "multi-search",
            body: queries,
            extraRequestInit,
        });
    }
    ///
    ///  Network
    ///
    /**
     * {@link https://www.meilisearch.com/docs/reference/api/network#get-the-network-object}
     *
     * @experimental
     */
    async getNetwork() {
        return await this.httpRequest.get({ path: "network" });
    }
    /**
     * {@link https://www.meilisearch.com/docs/reference/api/network#update-the-network-object}
     *
     * @experimental
     */
    async updateNetwork(network) {
        return await this.httpRequest.patch({
            path: "network",
            body: network,
        });
    }
    ///
    /// KEYS
    ///
    /**
     * Get all API keys
     *
     * @param parameters - Parameters to browse the indexes
     * @returns Promise returning an object with keys
     */
    async getKeys(parameters) {
        const keys = await this.httpRequest.get({
            path: "keys",
            params: parameters,
        });
        keys.results = keys.results.map((key) => ({
            ...key,
            createdAt: new Date(key.createdAt),
            updatedAt: new Date(key.updatedAt),
        }));
        return keys;
    }
    /**
     * Get one API key
     *
     * @param keyOrUid - Key or uid of the API key
     * @returns Promise returning a key
     */
    async getKey(keyOrUid) {
        return await this.httpRequest.get({
            path: `keys/${keyOrUid}`,
        });
    }
    /**
     * Create one API key
     *
     * @param options - Key options
     * @returns Promise returning a key
     */
    async createKey(options) {
        return await this.httpRequest.post({
            path: "keys",
            body: options,
        });
    }
    /**
     * Update one API key
     *
     * @param keyOrUid - Key
     * @param options - Key options
     * @returns Promise returning a key
     */
    async updateKey(keyOrUid, options) {
        return await this.httpRequest.patch({
            path: `keys/${keyOrUid}`,
            body: options,
        });
    }
    /**
     * Delete one API key
     *
     * @param keyOrUid - Key
     * @returns
     */
    async deleteKey(keyOrUid) {
        await this.httpRequest.delete({ path: `keys/${keyOrUid}` });
    }
    ///
    /// HEALTH
    ///
    /**
     * Checks if the server is healthy, otherwise an error will be thrown.
     *
     * @returns Promise returning an object with health details
     */
    async health() {
        return await this.httpRequest.get({ path: "health" });
    }
    /**
     * Checks if the server is healthy, return true or false.
     *
     * @returns Promise returning a boolean
     */
    async isHealthy() {
        try {
            const { status } = await this.health();
            return status === "available";
        }
        catch {
            return false;
        }
    }
    ///
    /// STATS
    ///
    /**
     * Get the stats of all the database
     *
     * @returns Promise returning object of all the stats
     */
    async getStats() {
        return await this.httpRequest.get({ path: "stats" });
    }
    ///
    /// VERSION
    ///
    /**
     * Get the version of MeiliSearch
     *
     * @returns Promise returning object with version details
     */
    async getVersion() {
        return await this.httpRequest.get({ path: "version" });
    }
    ///
    /// DUMPS
    ///
    /**
     * Creates a dump
     *
     * @returns Promise returning object of the enqueued task
     */
    createDump() {
        return this.#httpRequestsWithTask.post({
            path: "dumps",
        });
    }
    ///
    /// SNAPSHOTS
    ///
    /**
     * Creates a snapshot
     *
     * @returns Promise returning object of the enqueued task
     */
    createSnapshot() {
        return this.#httpRequestsWithTask.post({
            path: "snapshots",
        });
    }
}
//# sourceMappingURL=meilisearch.js.map