import { Index } from "./indexes.js";
import type { KeyCreation, Config, IndexOptions, IndexObject, Key, Health, Stats, Version, KeyUpdate, IndexesQuery, IndexesResults, KeysQuery, KeysResults, IndexSwap, MultiSearchParams, FederatedMultiSearchParams, MultiSearchResponseOrSearchResponse, EnqueuedTaskPromise, ExtraRequestInit, Network, RecordAny } from "./types/index.js";
import { HttpRequests } from "./http-requests.js";
import { TaskClient } from "./task.js";
import { BatchClient } from "./batch.js";
export declare class MeiliSearch {
    #private;
    config: Config;
    httpRequest: HttpRequests;
    get tasks(): TaskClient;
    get batches(): BatchClient;
    /**
     * Creates new MeiliSearch instance
     *
     * @param config - Configuration object
     */
    constructor(config: Config);
    /**
     * Return an Index instance
     *
     * @param indexUid - The index UID
     * @returns Instance of Index
     */
    index<T extends RecordAny = RecordAny>(indexUid: string): Index<T>;
    /**
     * Gather information about an index by calling MeiliSearch and return an
     * Index instance with the gathered information
     *
     * @param indexUid - The index UID
     * @returns Promise returning Index instance
     */
    getIndex<T extends RecordAny = RecordAny>(indexUid: string): Promise<Index<T>>;
    /**
     * Gather information about an index by calling MeiliSearch and return the raw
     * JSON response
     *
     * @param indexUid - The index UID
     * @returns Promise returning index information
     */
    getRawIndex(indexUid: string): Promise<IndexObject>;
    /**
     * Get all the indexes as Index instances.
     *
     * @param parameters - Parameters to browse the indexes
     * @returns Promise returning array of raw index information
     */
    getIndexes(parameters?: IndexesQuery): Promise<IndexesResults<Index[]>>;
    /**
     * Get all the indexes in their raw value (no Index instances).
     *
     * @param parameters - Parameters to browse the indexes
     * @returns Promise returning array of raw index information
     */
    getRawIndexes(parameters?: IndexesQuery): Promise<IndexesResults<IndexObject[]>>;
    /**
     * Create a new index
     *
     * @param uid - The index UID
     * @param options - Index options
     * @returns Promise returning Index instance
     */
    createIndex(uid: string, options?: IndexOptions): EnqueuedTaskPromise;
    /**
     * Update an index
     *
     * @param uid - The index UID
     * @param options - Index options to update
     * @returns Promise returning Index instance after updating
     */
    updateIndex(uid: string, options?: IndexOptions): EnqueuedTaskPromise;
    /**
     * Delete an index
     *
     * @param uid - The index UID
     * @returns Promise which resolves when index is deleted successfully
     */
    deleteIndex(uid: string): EnqueuedTaskPromise;
    /**
     * Deletes an index if it already exists.
     *
     * @param uid - The index UID
     * @returns Promise which resolves to true when index exists and is deleted
     *   successfully, otherwise false if it does not exist
     */
    deleteIndexIfExists(uid: string): Promise<boolean>;
    /**
     * Swaps a list of index tuples.
     *
     * @param params - List of indexes tuples to swap.
     * @returns Promise returning object of the enqueued task
     */
    swapIndexes(params: IndexSwap[]): EnqueuedTaskPromise;
    /**
     * Perform multiple search queries.
     *
     * It is possible to make multiple search queries on the same index or on
     * different ones. With network feature enabled, you can also search across
     * remote instances.
     *
     * @example
     *
     * ```ts
     * client.multiSearch({
     *   queries: [
     *     { indexUid: "movies", q: "wonder" },
     *     { indexUid: "books", q: "flower" },
     *   ],
     * });
     *
     * // Federated search with remote instance (requires network feature enabled)
     * client.multiSearch({
     *   federation: {},
     *   queries: [
     *     {
     *       indexUid: "movies",
     *       q: "wonder",
     *       federationOptions: {
     *         remote: "meilisearch instance name",
     *       },
     *     },
     *     {
     *       indexUid: "movies",
     *       q: "wonder",
     *       federationOptions: {
     *         remote: "meilisearch instance name",
     *       },
     *     },
     *   ],
     * });
     * ```
     *
     * @param queries - Search queries
     * @param extraRequestInit - Additional request configuration options
     * @returns Promise containing the search responses
     * @see {@link https://www.meilisearch.com/docs/learn/multi_search/implement_sharding#perform-a-search}
     */
    multiSearch<T1 extends MultiSearchParams | FederatedMultiSearchParams, T2 extends RecordAny = RecordAny>(queries: T1, extraRequestInit?: ExtraRequestInit): Promise<MultiSearchResponseOrSearchResponse<T1, T2>>;
    /**
     * {@link https://www.meilisearch.com/docs/reference/api/network#get-the-network-object}
     *
     * @experimental
     */
    getNetwork(): Promise<Network>;
    /**
     * {@link https://www.meilisearch.com/docs/reference/api/network#update-the-network-object}
     *
     * @experimental
     */
    updateNetwork(network: Partial<Network>): Promise<Network>;
    /**
     * Get all API keys
     *
     * @param parameters - Parameters to browse the indexes
     * @returns Promise returning an object with keys
     */
    getKeys(parameters?: KeysQuery): Promise<KeysResults>;
    /**
     * Get one API key
     *
     * @param keyOrUid - Key or uid of the API key
     * @returns Promise returning a key
     */
    getKey(keyOrUid: string): Promise<Key>;
    /**
     * Create one API key
     *
     * @param options - Key options
     * @returns Promise returning a key
     */
    createKey(options: KeyCreation): Promise<Key>;
    /**
     * Update one API key
     *
     * @param keyOrUid - Key
     * @param options - Key options
     * @returns Promise returning a key
     */
    updateKey(keyOrUid: string, options: KeyUpdate): Promise<Key>;
    /**
     * Delete one API key
     *
     * @param keyOrUid - Key
     * @returns
     */
    deleteKey(keyOrUid: string): Promise<void>;
    /**
     * Checks if the server is healthy, otherwise an error will be thrown.
     *
     * @returns Promise returning an object with health details
     */
    health(): Promise<Health>;
    /**
     * Checks if the server is healthy, return true or false.
     *
     * @returns Promise returning a boolean
     */
    isHealthy(): Promise<boolean>;
    /**
     * Get the stats of all the database
     *
     * @returns Promise returning object of all the stats
     */
    getStats(): Promise<Stats>;
    /**
     * Get the version of MeiliSearch
     *
     * @returns Promise returning object with version details
     */
    getVersion(): Promise<Version>;
    /**
     * Creates a dump
     *
     * @returns Promise returning object of the enqueued task
     */
    createDump(): EnqueuedTaskPromise;
    /**
     * Creates a snapshot
     *
     * @returns Promise returning object of the enqueued task
     */
    createSnapshot(): EnqueuedTaskPromise;
}
//# sourceMappingURL=meilisearch.d.ts.map